// LibreSolvE.Core/Parsing/AstBuilderVisitor.cs
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using LibreSolvE.Core.Ast;
using System;
using System.Globalization; // For consistent number parsing
using System.Linq;

namespace LibreSolvE.Core.Parsing;

/// <summary>
/// Visitor that walks the ANTLR parse tree generated by EesParser
/// and builds an Abstract Syntax Tree (AST) using LibreSolvE.Core.Ast node classes.
/// </summary>
public class AstBuilderVisitor : EesParserBaseVisitor<AstNode>
{
    /// <summary>
    /// Visits the root of the parse tree (the entire file).
    /// </summary>
    /// <param name="context">The parse tree context for the file.</param>
    /// <returns>An EesFileNode representing the root of the AST.</returns>
    public override AstNode VisitEesFile([NotNull] EesParser.EesFileContext context)
    {
        var fileNode = new EesFileNode();
        // Iterate through each statement context within the file context
        foreach (var statementContext in context.statement())
        {
            // Visit the specific statement alternative (e.g., AssignmentStatement, EquationStatement)
            var statementNode = Visit(statementContext);
            if (statementNode is StatementNode stmt)
            {
                fileNode.Statements.Add(stmt); // Add the resulting AST node to the file node's list
            }
            else if (statementNode != null)
            {
                // This case shouldn't typically happen if the grammar and visitor are correct,
                // but good for diagnostics if it does.
                Console.Error.WriteLine($"Warning: Visiting statement rule resulted in a non-StatementNode AST node: {statementNode.GetType().Name}");
            }
            // If statementNode is null, ANTLR might have skipped something or there was an issue.
        }
        return fileNode;
    }

    #region Statement Level Visitors
    // These methods correspond to the # labels on the 'statement' rule alternatives
    // in the grammar. They primarily delegate to the visitor for the specific
    // underlying rule (assignment or equation).

    /// <summary>
    /// Visits the context corresponding to the '# AssignmentStatement' label in the grammar.
    /// Delegates to visit the actual 'assignment' rule context contained within.
    /// </summary>
    public override AstNode VisitAssignmentStatement([NotNull] EesParser.AssignmentStatementContext context)
    {
        // The context holds the result of matching the 'assignment' rule. Visit that specific rule context.
        return Visit(context.assignment());
    }

    /// <summary>
    /// Visits the context corresponding to the '# EquationStatement' label in the grammar.
    /// Delegates to visit the actual 'equation' rule context contained within.
    /// </summary>
    public override AstNode VisitEquationStatement([NotNull] EesParser.EquationStatementContext context)
    {
        // The context holds the result of matching the 'equation' rule. Visit that specific rule context.
        return Visit(context.equation());
    }
    #endregion

    #region Rule Level Visitors
    // These methods visit the specific grammar rules (equation, assignment alternatives)
    // and construct the corresponding AST nodes using the labeled elements from the grammar.

    /// <summary>
    /// Visits the 'equation' rule context.
    /// Constructs an EquationNode from the left-hand side and right-hand side expressions.
    /// </summary>
    public override AstNode VisitEquation([NotNull] EesParser.EquationContext context)
    {
        // Grammar rule: equation: lhs=expression EQ rhs=expression SEMI? ;
        ExpressionNode lhs = (ExpressionNode)Visit(context.lhs); // Visit the labeled 'lhs' expression
        ExpressionNode rhs = (ExpressionNode)Visit(context.rhs); // Visit the labeled 'rhs' expression
        return new EquationNode(lhs, rhs);
    }

    /// <summary>
    /// Visits the 'ExplicitAssignment' rule context (using ':=').
    /// Constructs an AssignmentNode.
    /// </summary>
    public override AstNode VisitExplicitAssignment([NotNull] EesParser.ExplicitAssignmentContext context)
    {
        // Grammar rule: assignment: variable=ID ASSIGN rhs=expression SEMI?   # ExplicitAssignment
        string varName = context.variable.Text; // Get text from the labeled 'variable' ID token
        VariableNode variableNode = new VariableNode(varName);
        ExpressionNode rhs = (ExpressionNode)Visit(context.rhs); // Visit the labeled 'rhs' expression
        return new AssignmentNode(variableNode, rhs);
    }

    /// <summary>
    /// Visits the 'ImplicitAssignment' rule context (using '=').
    /// Constructs an EquationNode, reflecting EES semantics where 'Var = Expr' is an equation.
    /// </summary>
    public override AstNode VisitImplicitAssignment([NotNull] EesParser.ImplicitAssignmentContext context)
    {
        // Grammar rule: assignment: variable=ID EQ rhs=expression SEMI?       # ImplicitAssignment
        // Create an EquationNode because '=' means equality in EES equations.
        VariableNode lhs = new VariableNode(context.variable.Text); // The variable is the LHS expression
        ExpressionNode rhs = (ExpressionNode)Visit(context.rhs);   // Visit the labeled 'rhs' expression
        return new EquationNode(lhs, rhs);
    }
    #endregion

    #region Expression Visitors
    // These methods visit the different expression rule alternatives (# labels)
    // and construct the corresponding AST expression nodes.

    /// <summary>
    /// Visits a multiplication or division expression.
    /// </summary>
    public override AstNode VisitMulDivExpr([NotNull] EesParser.MulDivExprContext context)
    {
        ExpressionNode left = (ExpressionNode)Visit(context.left);   // Visit labeled left operand
        ExpressionNode right = (ExpressionNode)Visit(context.right); // Visit labeled right operand
        // Determine operator type based on the token type from the labeled 'op'
        BinaryOperator op = context.op.Type == EesLexer.MUL ? BinaryOperator.Multiply : BinaryOperator.Divide;
        return new BinaryOperationNode(left, op, right);
    }

    /// <summary>
    /// Visits an addition or subtraction expression.
    /// </summary>
    public override AstNode VisitAddSubExpr([NotNull] EesParser.AddSubExprContext context)
    {
        ExpressionNode left = (ExpressionNode)Visit(context.left);   // Visit labeled left operand
        ExpressionNode right = (ExpressionNode)Visit(context.right); // Visit labeled right operand
        // Determine operator type based on the token type from the labeled 'op'
        BinaryOperator op = context.op.Type == EesLexer.PLUS ? BinaryOperator.Add : BinaryOperator.Subtract;
        return new BinaryOperationNode(left, op, right);
    }

    /// <summary>
    /// Visits a power expression. Needs POW token in Lexer and rule in Parser if not already present.
    /// Assuming POW token exists and a rule like:
    /// expression : left=expression op=POW right=expression # PowExpr
    /// </summary>
    // public override AstNode VisitPowExpr([NotNull] EesParser.PowExprContext context)
    // {
    //     ExpressionNode left = (ExpressionNode)Visit(context.left);
    //     ExpressionNode right = (ExpressionNode)Visit(context.right);
    //     return new BinaryOperationNode(left, BinaryOperator.Power, right);
    // }


    /// <summary>
    /// Visits a parenthesized expression. Returns the AST node for the inner expression.
    /// </summary>
    public override AstNode VisitParenExpr([NotNull] EesParser.ParenExprContext context)
    {
        // Grammar rule: atom: LPAREN expression RPAREN # ParenExpr
        // Simply visit the nested expression context
        return Visit(context.expression());
    }

    /// <summary>
    /// Visits the base case 'atom' expression, which simply delegates to the specific atom type.
    /// This method might not be strictly necessary if all atom alternatives are handled directly,
    /// but overriding it can sometimes help with debugging or complex aggregation.
    /// </summary>
    // public override AstNode VisitAtomExpr([NotNull] EesParser.AtomExprContext context)
    // {
    //      return base.VisitAtomExpr(context); // Or Visit(context.atom());
    // }

    #endregion

    #region Atom Visitors
    // These methods visit the specific atom rule alternatives (# labels)

    /// <summary>
    /// Visits a NUMBER literal token and creates a NumberNode.
    /// </summary>
    public override AstNode VisitNumberAtom([NotNull] EesParser.NumberAtomContext context)
    {
        string text = context.NUMBER().GetText();
        // Use InvariantCulture for reliable decimal parsing regardless of system locale
        if (double.TryParse(text, NumberStyles.Any, CultureInfo.InvariantCulture, out double value))
        {
            return new NumberNode(value);
        }
        // It's generally better to throw a more specific exception or handle errors gracefully.
        throw new FormatException($"Could not parse number: {text}");
    }

    /// <summary>
    /// Visits an ID token and creates a VariableNode.
    /// </summary>
    public override AstNode VisitVariableAtom([NotNull] EesParser.VariableAtomContext context)
    {
        return new VariableNode(context.ID().GetText());
    }

    // TODO: Add VisitFunctionCallAtom when function calls are added to the grammar
    // public override AstNode VisitFuncCallAtom([NotNull] EesParser.FuncCallAtomContext context)
    // {
    //     return Visit(context.functionCall());
    // }
    // public override AstNode VisitFunctionCall([NotNull] EesParser.FunctionCallContext context)
    // {
    //     // Logic to create FunctionCallNode
    // }

    #endregion

    #region Default Aggregation (Optional)
    /// <summary>
    /// Controls how results from visiting multiple children are combined.
    /// The default ANTLR behavior often returns the result of the last child visited.
    /// For building a specific AST node in overridden methods, this default is usually fine.
    /// </summary>
    protected override AstNode AggregateResult(AstNode aggregate, AstNode nextResult)
    {
        return nextResult ?? aggregate;
    }
    #endregion
}
